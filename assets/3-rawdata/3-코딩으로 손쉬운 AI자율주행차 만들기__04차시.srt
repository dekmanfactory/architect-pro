1
00:00:01,000 --> 00:00:05,000
[4차시: 픽셀에서 차선을 추출하다] 안녕하세요! 지난 시간에 추출한 엣지 데이터를 기억하시나요?

2
00:00:05,500 --> 00:00:10,000
오늘은 흩어진 점(픽셀)들을 하나의 직선, 즉 '차선'으로 연결하는 마법 같은 기술을 배웁니다.

3
00:00:10,500 --> 00:00:15,500
핵심 알고리즘은 '허프 변환(Hough Transform)'입니다. 이미지 공간의 점들을 파라미터 공간으로 옮겨 직선을 찾는 방식이죠.

4
00:03:00,000 --> 00:03:05,500
파이썬 OpenCV의 `HoughLinesP` 함수를 사용하면 복잡한 수학 연산을 단 몇 줄의 코드로 해결할 수 있습니다.

5
00:03:06,000 --> 00:03:11,000
함수의 인자값인 임계값과 최소 선 길이를 조절하며 도로 위의 잡음을 제거하고 차선만 남겨봅시다.

6
00:06:00,000 --> 00:06:05,500
이제 왼쪽 차선과 오른쪽 차선을 구분해 볼까요? 선의 '기울기'를 계산하면 간단히 해결됩니다.

7
00:09:00,000 --> 00:09:14,000
기울기가 양수면 오른쪽, 음수면 왼쪽 차선으로 분류하여 각각의 대표선을 그리는 로직을 코딩합니다.

8
00:12:00,000 --> 00:12:05,500
하지만 도로 위엔 차선만 있는 게 아니죠. 옆 차선의 차나 가드레일을 차선으로 착각하지 않게 필터링해야 합니다.

9
00:12:06,000 --> 00:12:11,000
우리가 3차시에서 배운 ROI 영역 안에서만 선을 찾도록 범위를 제한하여 정확도를 높여보겠습니다.

10
00:15:00,000 --> 00:15:05,000
인식된 차선 위에 실시간으로 초록색 가이드라인을 덧입히는 오버레이(Overlay) 작업도 실습합니다.

11
00:18:00,000 --> 00:18:05,500
영상이 흔들려도 차선을 놓치지 않도록 이전 프레임의 위치를 기억하는 '이동 평균' 기법을 맛보기로 살펴봅니다.

12
00:21:00,000 --> 00:21:05,500
차선이 인식되었다는 것은 자동차가 "내가 도로 어디쯤 있구나"를 알게 되었다는 중요한 진보입니다.

13
00:24:00,000 --> 00:24:05,000
직선뿐만 아니라 곡선 구간에서도 차선을 잘 유지할 수 있도록 코드를 최적화하는 팁도 공유해 드릴게요.

14
00:27:00,000 --> 00:27:05,000
실습 화면에 두 개의 선이 선명하게 나타나고 중앙 경로가 계산된다면 오늘 목표 달성입니다.

15
00:27:05,500 --> 00:27:11,000
4차시 수고하셨습니다! 다음 시간에는 인식된 차선을 바탕으로 바퀴를 얼마나 꺾을지 결정하는 '조향 제어'를 배웁니다.